You are a Senior Computational Intelligence Engineer specializing in Multimodal Optimization Problems (MMOP) and Python NumPy programming.
Your Goal: Optimize Strategy C (funcC), which is the Selection & Archiving module of a Niching Differential Evolution algorithm.

Strategy A has clustered the population. Strategy B has generated offspring.
Strategy C's task is to:
1. Decide whether the offspring replaces the parent (Selection).
2. Identify and save "Peak Solutions" into an external archive (Elite Preservation).
3. Ensure the main population maintains diversity and does not converge to a single peak.

--------------------------------------------------
### Context: Interface Constraints (CRITICAL)
Strategy C is the final step of the iteration. You must strictly adhere to the following Input/Output interface. Failure to follow these constraints will cause the main loop to crash.

1. Input Data:
- `step2`: A list of length `pop_size` generated by Strategy B. Each element is a list: `[parent_vec, parent_fit, child_vec, child_fit]`.
- `elite_population`: A NumPy array of shape (k, dim) containing currently found peaks. `k` is dynamic (starts at 0).
- `elite_fitness`: A 1-D NumPy array of shape (k,).
- `progress`: Float (0.0 to 1.0).
- `parameters`: Dictionary containing `dim`, `pop_size`, `evaluate`.

2. Expected Output:
- You MUST return a tuple containing exactly 4 elements: `(elite_population, elite_fitness, new_population, new_fitness)`.
- `elite_population`: Updated archive (NumPy array, shape (k_new, dim)).
- `elite_fitness`: Updated archive fitness (NumPy array, shape (k_new,)).
- `new_population`: The main population for the next generation (NumPy array, shape (pop_size, dim)). Size MUST remain constant.
- `new_fitness`: The fitness of the main population (NumPy array, shape (pop_size,)).

3. Strict Logical Constraints:
- Deterministic Crowding: In the main population, the offspring should ONLY compete with its specific parent (index-to-index comparison). Do NOT sort the whole population by fitness.
- Archiving Rule: A solution should only be added to `elite_population` if it is a high-quality local optimum AND it is sufficiently far (Euclidean distance) from existing elites.
- Data Types: All outputs must be NumPy arrays of `dtype=float`.

--------------------------------------------------
The Framework :
{code_bone}

### Parents for Crossover
We have two variants of Strategy C from previous experiments.

Parent 1 (Better Performance):
Score: {score_better}
Code:
{code_better}

Parent 2 (Worse Performance):
Score: {score_worse}
Code:
{code_worse}

--------------------------------------------------
### Analysis & Reflection
Analysis of why Parent 2 performed worse compared to Parent 1, and potential areas for improvement.Analysis is allowed only in the form of Python comments (#) inside the modified strategy functions.
Any non-comment text outside code blocks is forbidden.

--------------------------------------------------
### Your Task
Generate a NEW Strategy C (funcC) by performing a "crossover" and improvement on the two parents above.

1. Inherit the robust selection logic from Parent 1 (ensuring population size stability).
2. Integrate smarter archiving mechanisms from Parent 2 (e.g., dynamic clearing radius, better peak detection logic) if they are promising, but fix their implementation flaws.
3. Refine Peak Maintenance: Ensure that the archive doesn't grow infinitely with duplicate peaks. Implement a check: `if min_dist(candidate, elites) > threshold`.
4. Strictly follow the Input/Output format defined above.

Output Format:
# BEGIN: modify Strategy C
def funcC(step2, elite_population, elite_fitness, progress, parameters):
    import numpy as np
    # ... your optimized code here ...
    return elite_population, elite_fitness, new_population, new_fitness
# END: Strategy C modification finished

Do not output any text outside the BEGIN/END blocks.