You are a Senior Computational Intelligence Engineer specializing in Multimodal Optimization Problems (MMOP) and Python NumPy programming.
Your Goal: Mutate and improve Strategy C (funcC), which is the Selection & Archiving module.

We have identified an Elite Strategy C that effectively selects survivors and maintains an archive.
Your task is to act as a "Mutation Operator": Take this elite code and introduce a novel logic change to improve how peaks are detected, stored, or maintained.

--------------------------------------------------
### Context: Interface Constraints (CRITICAL)
Strategy C manages the population lifecycle. You must strictly adhere to the following Input/Output interface.

1. Input Data:
- `step2`: List of `[parent, p_fit, child, c_fit]` from Strategy B.
- `elite_population`: NumPy array (k, dim).
- `elite_fitness`: NumPy array (k,).
- `progress`: Float (0.0 to 1.0).
- `parameters`: Dictionary containing `pop_size`, `dim`.

2. Expected Output:
- You MUST return a tuple: `(elite_population, elite_fitness, new_population, new_fitness)`.
- `new_population` size must be exactly `(pop_size, dim)`.

3. Strict Logical Constraints:
- Deterministic Crowding: Compare child vs parent (index-to-index). Do NOT perform global sorting for the main population.
- Archive Purity: Only add to `elite_population` if the solution is distinct (Euclidean distance > threshold) from existing elites.

--------------------------------------------------
The Framework :
{code_bone}
### Current Elite Strategy (The Seed)
Performance Score: {score}
Code:
{code}

--------------------------------------------------
### Mutation Directions (Ideas for Improvement)
Consider implementing ONE of the following mutations to the elite code:
1.  Dynamic Archiving Threshold: Instead of a fixed distance threshold (e.g., 0.1), make the threshold dynamic. Start large to find distinct basins, then shrink it over time to capture closer peaks.
2.  Stagnation & Restart: Add logic to detect if an individual has not improved for N generations (you can use random replacement for stagnated individuals to search new areas).
3.  Archive Pruning: If the archive gets too large, implement a logic to remove the "worst" elites or "most crowded" elites to save resources.
4.  Hill-Valley Detection: (Advanced) Before archiving, check the midpoint between the candidate and the nearest elite. If the midpoint fitness is lower than both, it's a real separate peak (Hill-Valley function).

--------------------------------------------------
### Your Task
Generate a Mutated Strategy C based on the Elite Strategy above.
1.  Analyze the Elite Strategy.
2.  Apply a significant mutation (logic change) to improve peak detection accuracy or diversity maintenance.
3.  Strictly follow the Input/Output format defined above.

Output Format:
# BEGIN: mutate Strategy C
def funcC(step2, elite_population, elite_fitness, progress, parameters):
    import numpy as np
    # ... your mutated code here ...
    return elite_population, elite_fitness, new_population, new_fitness
# END: Strategy C mutation finished

Do not output any text outside the BEGIN/END blocks.